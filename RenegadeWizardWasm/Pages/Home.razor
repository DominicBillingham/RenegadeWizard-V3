@page "/"
@inject IJSRuntime JS

@using RenegadeWizardWasm.Core
@using RenegadeWizardWasm.Core.UserInterface
@inject GameCoordinator GameCoordinator;

<PageTitle>Home</PageTitle>

<div class="bg-animation">
    <div id='stars'></div>
    <div id='stars2'></div>
    <div id='stars3'></div>
    <div id='stars4'></div>
    <div class="moon"></div>
    @* <div class="mountain-container"> *@
    @*     <div class="sun"></div> *@
    @*     <div class="mountain"></div> *@
    @* </div> *@
</div><!-- / STAR ANIMATION -->

<div class="console-container">
    <div class="console-column m-auto" id="mainDisplay">
        <div class="console-output" id="consoleOutput">
            @foreach (var line in ConsoleLines)
            {
                <div class="console-line">@((MarkupString)line)</div>
            }
        </div>
        <TerminalInput LastResponse="@LastResponse" PendingLines="@PendingLines" OnSubmit="HandleInputSubmit" OnAdvancePending="HandleAdvancePending" />
        <EntityBubbleContainer CreatureCards="@LastResponse.CreatureCards" ObjectCards="@LastResponse.ObjectCards" />
    </div>
</div>

@code {
    
    private List<string> ConsoleLines { get; set; } = new();
    private List<string> PendingLines { get; set; } = new();
    private GameResponse LastResponse { get; set; } = new();
    private bool ShouldScroll { get; set; } = false;

    protected override async Task OnInitializedAsync()
    {
        GameResponse response = GameCoordinator.StartGame();
        await UpdateTerminal(response, false);
    }

    private async Task HandleAdvancePending()
    {
        if (PendingLines.Count > 0)
        {
            bool paused = false;
            if (ConsoleLines.Any())
            {
                var lastLineIndex = ConsoleLines.Count - 1;
                ConsoleLines[lastLineIndex] = ConsoleLines[lastLineIndex].Replace("▼", "").Replace("[press enter]", "");
            }

            while (PendingLines.Count > 0 && !paused)
            {
                string line = PendingLines[0];
                PendingLines.RemoveAt(0);
                ConsoleLines.Add(MiniMarkup.ConvertString(line));

                if (line.Contains("▼"))
                {
                    paused = true;
                }
            }

            ShouldScroll = true;
            StateHasChanged();
        }
    }

    private async Task HandleInputSubmit(string userInput)
    {
        GameResponse response = GameCoordinator.EnterInput(userInput);
        await UpdateTerminal(response, true);
    }

    public async Task UpdateTerminal(GameResponse response, bool shouldScroll)
    {
        List<string> lines = response.Text;
        bool paused = false;

        for (int i = 0; i < lines.Count; i++)
        {
            if (paused)
            {
                PendingLines.Add(lines[i]);
                continue;
            }

            string line = lines[i];
            ConsoleLines.Add(MiniMarkup.ConvertString(line));

            if (line.Contains("▼"))
            {
                paused = true;
            }
        }

        LastResponse = response;

        ShouldScroll = shouldScroll;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (ShouldScroll)
        {
            await JS.InvokeVoidAsync("ScrollToBottom");
            ShouldScroll = false;
        }
    }

    private async Task PlaySound(string audio, bool overrideAudio)
    {
        await JS.InvokeVoidAsync("PlaySound", audio, overrideAudio);
    }
}

<script src="/javascript/terminal.js"></script>